Index: base.h
===================================================================
--- base.h	(revision 599)
+++ base.h	(working copy)
@@ -46,7 +46,7 @@
 	#define BP_USE_RAW2WIRE
 	#define BP_USE_RAW3WIRE
 	//#define BP_USE_PCATKB
-	#define BP_USE_LCD // include HD44780 LCD library
+	//#define BP_USE_LCD // include HD44780 LCD library
 	//#define BP_USE_PIC
 	#define BP_USE_DIO //binary mode
 #elif defined(BP_ADDONS)
@@ -66,7 +66,6 @@
 	#error "No Bus Pirate configuration defined."
 #endif
 
-
 #define BP_USE_BASIC   // basic subsystem
 //#define BP_USE_BASICI2C  // use an i2ceeprom for storing
 
Index: SPI.c
===================================================================
--- SPI.c	(revision 599)
+++ SPI.c	(working copy)
@@ -25,6 +25,9 @@
 
 #ifdef BP_USE_HWSPI
 
+// enable special AVR-specific commands for bulk flash reading and other purposes
+#define AVR_EXTENDED_COMMANDS
+
 //direction registers
 #define SPIMOSI_TRIS 	BP_MOSI_DIR	
 #define SPICLK_TRIS 	BP_CLK_DIR	
@@ -125,7 +128,7 @@
 	if(modeConfig.wwr==1){
 		return r;
 	}
-	//FIXME what to return if wwr=0? we need an uint here
+	//FIXME what to return if wwr=0? we need an uint here
 }
 
 void SPIsettings(void)
@@ -554,6 +557,10 @@
     * 0100wxyz – Configure peripherals, w=power, x=pullups, y=AUX, z=CS
     * 01100xxx – Set SPI speed, 30, 125, 250khz; 1, 2, 2.6, 4, 8MHz
     * 1000wxyz – SPI config, w=output type, x=idle, y=clock edge, z=sample
+    * 00000110 - AVR Extended Commands
+      * 00000000 - Null operation - verifies extended commands are available.
+      * 00000001 - Return version (2 bytes)
+      * 00000010 - Bulk Memory Read from Flash
 	
 */
 static unsigned char binSPIspeed[]={0b00000,0b11000,0b11100,0b11101,0b00011,0b01000,0b10000,0b11000};//00=30,01=125,10=250,11=1000khz, 100=2mhz,101=2.667mhz,  110=4mhz, 111=8mhz; datasheet pg 142
@@ -563,6 +570,9 @@
 void binSPI(void){
 	static unsigned char inByte, rawCommand, i;
 	unsigned int j, fw, fr;
+#ifdef AVR_EXTENDED_COMMANDS
+	unsigned long saddr, length;
+#endif
 
 	//useful default values
 	/* CKE=1, CKP=0, SMP=0 */
@@ -656,6 +666,71 @@
                         }
 
                         break;
+#ifdef AVR_EXTENDED_COMMANDS
+					case 6:	// AVR Extended Commands
+						UART1TX(1); // send 1/OK (ie, AVR Extended Commands accepted)
+
+						while(U1STAbits.URXDA == 0);//wait for a byte
+						inByte=U1RXREG; //grab it
+
+						switch (inByte) {
+							case 0x00: // null operation, return OK
+								UART1TX(1);	// send 1/OK
+								break;
+							case 0x01: // version check
+								UART1TX(1); // send 1/OK
+								UART1TX(0x00);
+								UART1TX(0x01); // version 1
+								break;
+							case 0x02: // bulk memory read from flash
+								// read in the start address (4 bytes, MSB first)
+								saddr = 0;
+								for (j=0; j < 4; j++) {
+									while(U1STAbits.URXDA == 0);//wait for a byte
+									inByte=U1RXREG; //grab it
+									saddr = (saddr << 8) | inByte;
+								}
+
+								// read in the bytes to read (4 bytes, MSB first) [inclusive]
+								length = 0;
+								for (j=0; j < 4; j++) {
+									while(U1STAbits.URXDA == 0);//wait for a byte
+									inByte=U1RXREG; //grab it
+									length = (length << 8) | inByte;
+								}
+
+								// FIXME - Can't handle pages past the first 64kb
+								if (saddr > 0xFFFF || length > 0xFFFF || (saddr+length) > 0xFFFF) {
+									UART1TX(0);
+								} else {
+									// just assume it'll work...
+									UART1TX(0x01); // send 1/OK
+
+									for (j=saddr; length > 0; j++) {
+										// fetch low byte from this memory word
+										spiWriteByte(0x20);
+										spiWriteByte(j >> 8);
+										spiWriteByte(j & 0xFF);
+										UART1TX(spiWriteByte(0x00));  // fetch byte that was read
+										length--;
+
+										if (length == 0) break;
+			
+										// fetch high byte from this memory word
+										spiWriteByte(0x28);
+										spiWriteByte(j >> 8);
+										spiWriteByte(j & 0xFF);
+										UART1TX(spiWriteByte(0x00));  // fetch byte that was read
+										length--;
+									}
+								}																
+								break;					
+							default:
+								UART1TX(0);
+								break;
+						}
+#endif
+						break;
 					default:
 						UART1TX(0);
 						break;
